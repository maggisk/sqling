import assert from "assert";
import fs from "fs";
import ts from "typescript";
import { DatabaseError } from "pg-protocol";
import chokidar from "chokidar";
import { ClientConfig } from "pg";
import { connect, describeQuery, getPgTypes, listTablesAndColumns } from "./db";
import { red, green, explainQueryError } from "./utils";
import Mutex from "./mutex";
import * as types from "./types";
import * as astUtils from "./astUtils";

interface Generator {
  db: types.Database;
  types: types.TypeMap;
  catalog: types.Catalog;
}

const typemap: Record<string, string> = {
  int8: "string", // node-postgres also returns 64 bit ints as strings
  int: "number",
  float: "number",
  numeric: "number",
  bool: "boolean",
  json: "runtime.Json",
  jsonb: "runtime.Json",
  text: "string",
  char: "string",
  varchar: "string",
  uuid: "string",
  timestamp: "Date",
  timestamptz: "Date"
};

const lines = (...args: Array<string | string[]>): string => {
  return args.flatMap(x => (Array.isArray(x) ? x : [x])).join("\n");
};

const collectQueries = (filePath: string): Array<[string, types.QueryDef]> => {
  const code = fs.readFileSync(filePath, { encoding: "utf-8" });
  const ast = ts.createSourceFile(filePath, code, ts.ScriptTarget.Latest);

  return astUtils.extractQueriesFromAst(ast).map(([name, node]) => {
    return [name, astUtils.extractQueryString(node)];
  });
};

const pgTypeIdToTsType = (typeMap: types.TypeMap, typeId: number): string => {
  const type = typeMap[typeId];
  const tsTypeName =
    typemap[type?.name] ?? typemap[type?.name.replace(/\d/g, "")] ?? "unknown";

  if (tsTypeName === "unknown") console.log(type);
  return tsTypeName + (type.isArray ? "[]" : "");
};

const generateInputType = (
  types: types.TypeMap,
  { input }: types.QueryDescription,
  { keys }: types.QueryDef
): string[] => {
  const uniq = Array.from(new Set(keys)).sort();
  return uniq.map(k => {
    return `${k}: ${pgTypeIdToTsType(types, input[keys.indexOf(k)])} | null`;
  });
};

const generateReturnType = (
  types: types.TypeMap,
  catalog: types.Catalog,
  desc: types.QueryDescription
): string[] => {
  return Array.from(desc.output)
    .sort((a, b) => (a.name < b.name ? -1 : 1))
    .map(x => {
      let type = pgTypeIdToTsType(types, x.dataTypeID);
      const col = catalog.tables.get(x.tableID)?.columns.get(x.columnID);
      return `${x.name}: ${type} ${col?.nullable ? "| null" : ""}`.trim();
    });
};

const generateQuery = async (
  { db, types, catalog }: Generator,
  sourceFile: string,
  name: string,
  query: types.QueryDef
): Promise<string> => {
  const id = name.charAt(0).toUpperCase() + name.substring(1);
  const description = await describeQuery(db, query.sql);
  const identifier = `${sourceFile}: ${name}`;

  if (description instanceof DatabaseError) {
    console.error(`${identifier} ${red(description.message)}`);
    console.error(explainQueryError(query.sql, description));
    return lines(
      "// Query error",
      `export type ${id}Input = never`,
      `export type ${id}Output = never`,
      `export const ${name} = null`
    );
  }

  console.log(`${identifier} ${green("ok")}`);

  return lines(
    `export interface ${id}Input {`,
    generateInputType(types, description, query).map(s => "  " + s),
    `}`,
    "",
    `export interface ${id}Output {`,
    generateReturnType(types, catalog, description).map(s => "  " + s),
    `}`,
    "",
    `export const ${name} = new runtime.Query<${id}Input, ${id}Output>(`,
    `  ${JSON.stringify(query.sql)},`,
    `  ${query.keys.length ? JSON.stringify(query.keys) : "[]"}`,
    `)`
  );
};

const writeFile = async (
  genState: Generator,
  sourceFile: string
): Promise<void> => {
  const queryCode = await Promise.all(
    collectQueries(sourceFile).map(async ([name, query]) => {
      return await generateQuery(genState, sourceFile, name, query);
    })
  );

  const code = lines(
    "import * as runtime from 'sqling/lib/runtime'",
    "",
    "/* THIS FILE IS AUTOMATICALLY GENERATED BY SQLING. DO NOT EDIT IT DIRECTLY */",
    "",
    queryCode
  );

  const destFile = sourceFile.replace(/\.([^.]*?)$/, ".sql.$1");
  assert(destFile !== sourceFile, "attempted to overwrite input file");
  fs.writeFileSync(destFile, code, { encoding: "utf8" });
};

export const generate = async ({
  glob,
  pgConfig,
  watch = true,
  afterWrite = () => {}
}: {
  glob: string | string[];
  pgConfig: ClientConfig;
  watch: boolean;
  afterWrite?: (path: string) => void | Promise<void>;
}): Promise<void> => {
  const mutexes: Record<string, Mutex> = {};
  const db = await connect(pgConfig);
  const generator = {
    db,
    types: await getPgTypes(db.client),
    catalog: await listTablesAndColumns(db.client)
  };

  let ready = false;
  const watcher = chokidar
    .watch(glob)
    .on("ready", () => {
      ready = true;
      if (!watch) {
        watcher.close()
      }
    })
    .on("all", (_event, path, _stats) => {
      if (path.endsWith(".sql.ts")) return;

      if (!mutexes[path]) {
        mutexes[path] = new Mutex();
      }
      mutexes[path].synchronize(async () => {
        try {
          if (ready) {
            generator.catalog = await listTablesAndColumns(db.client);
          }
          await writeFile(generator, path);
          await afterWrite(path);
        } catch (e) {
          console.error(e);
        }
      });
    });
};
