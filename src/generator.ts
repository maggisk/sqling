import assert from "assert";
import fs from "fs";
import ts from "typescript";
import { DatabaseError } from "pg-protocol";
import chokidar from "chokidar";
import { ClientConfig } from "pg";
import { connect, describeQuery, getPgTypes } from "./db";
import { red, green, explainQueryError } from "./utils";
import Mutex from "./mutex";
import * as types from "./types";
import * as astUtils from "./astUtils";

interface Generator {
  conn: types.Connection;
  types: types.TypeMap;
}

const typemap: Record<string, string> = {
  int8: "string", // node-postgres also returns 64 bit ints as strings
  int: "number",
  float: "number",
  numeric: "number",
  bool: "boolean",
  json: "runtime.Json",
  jsonb: "runtime.Json",
  text: "string",
  char: "string",
  varchar: "string",
  uuid: "string",
  timestamp: "Date",
  timestamptz: "Date"
};

const lines = (...args: Array<string | string[]>): string => {
  return args.flatMap(x => (Array.isArray(x) ? x : [x])).join("\n");
};

const collectQueries = (filePath: string): Array<[string, types.QueryDef]> => {
  const code = fs.readFileSync(filePath, { encoding: "utf-8" });
  const ast = ts.createSourceFile(filePath, code, ts.ScriptTarget.Latest);

  return astUtils.extractQueriesFromAst(ast).map(([name, node]) => {
    return [name, astUtils.extractQueryString(node)];
  });
};

const pgTypeIdToTsType = (typeMap: types.TypeMap, typeId: number): string => {
  const type = typeMap[typeId];
  const tsTypeName =
    typemap[type.name] ?? typemap[type.name.replace(/\d/g, "")] ?? "unknown";

  if (tsTypeName === "unknown") console.log(type);
  return tsTypeName + (type.isArray ? "[]" : "");
};

const generateInputType = (
  types: types.TypeMap,
  { input }: types.QueryDescription,
  { keys }: types.QueryDef
): string[] => {
  const uniq = Array.from(new Set(keys)).sort();
  return uniq.map(k => {
    return `${k}: ${pgTypeIdToTsType(types, input[keys.indexOf(k)])}`;
  });
};

const generateReturnType = (
  types: types.TypeMap,
  desc: types.QueryDescription
): string[] => {
  return Array.from(desc.output)
    .sort((a, b) => (a.name < b.name ? -1 : 1))
    .map(x => `${x.name}: ${pgTypeIdToTsType(types, x.dataTypeID)}`);
};

const generateQuery = async (
  { conn, types }: Generator,
  sourceFile: string,
  name: string,
  query: types.QueryDef
): Promise<string> => {
  const id = name.charAt(0).toUpperCase() + name.substring(1);
  const description = await describeQuery(conn, query.sql);
  const identifier = `${sourceFile}: ${name}`;

  if (description instanceof DatabaseError) {
    console.error(`${identifier} ${red(description.message)}`);
    console.error(explainQueryError(query.sql, description));
    return lines(
      "// Query error",
      `export type ${id}Input = never`,
      `export type ${id}Output = never`,
      `export const ${name} = null`
    );
  }

  console.log(`${identifier} ${green("ok")}`);

  return lines(
    `export interface ${id}Input {`,
    generateInputType(types, description, query).map(s => "  " + s),
    `}`,
    "",
    `export interface ${id}Output {`,
    generateReturnType(types, description).map(s => "  " + s),
    `}`,
    "",
    `export const ${name} = new runtime.Query<${id}Input, ${id}Output>(`,
    `  ${JSON.stringify(query.sql)},`,
    `  ${query.keys.length ? JSON.stringify(query.keys) : "undefined"}`,
    `)`
  );
};

const writeFile = async (
  genState: Generator,
  sourceFile: string
): Promise<void> => {
  const queryCode = await Promise.all(
    collectQueries(sourceFile).map(async ([name, query]) => {
      return await generateQuery(genState, sourceFile, name, query);
    })
  );

  const code = lines(
    "import * as runtime from 'sqling/lib/runtime'",
    "",
    "/* THIS FILE IS AUTOMATICALLY GENERATED BY SQLING. DO NOT EDIT IT DIRECTLY */",
    "",
    queryCode
  );

  const destFile = sourceFile.replace(/\.(.*?)$/, ".sql.$1");
  assert(destFile !== sourceFile, "attempted to overwrite input file");
  fs.writeFileSync(destFile, code, { encoding: "utf8" });
};

export const generate = async ({
  glob,
  pgConfig,
  outfile,
  afterWrite = () => {}
}: {
  glob: string | string[];
  pgConfig: ClientConfig;
  outfile: string;
  afterWrite?: (path: string) => void | Promise<void>;
}): Promise<void> => {
  const mutexes: Record<string, Mutex> = {};
  const genState = {
    conn: await connect(pgConfig),
    types: await getPgTypes(pgConfig)
  };

  chokidar.watch(glob).on("all", (_event, path, _stats) => {
    if (path.endsWith(".sql.ts")) return;

    if (!mutexes[path]) {
      mutexes[path] = new Mutex();
    }
    mutexes[path].synchronize(async () => {
      try {
        await writeFile(genState, path);
        await afterWrite(path);
      } catch (e) {
        console.error(e);
      }
    });
  });
};
