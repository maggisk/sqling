import assert from "assert";
import fs from "fs";
import { join } from "path";
import { DatabaseError } from "pg-protocol";
import chokidar from "chokidar";
import { ClientConfig } from "pg";
import { connect, describeQuery, getPgTypes } from "./db";
import { QueryDef } from "./builder";
import { red, green, yellow, explainQueryError } from "./utils";
import Mutex from "./mutex";
import * as types from "./types";

interface Context {
  conn: types.Connection;
  types: types.TypeMap;
}

const typemap: Record<string, string> = {
  int8: "string", // node-postgres also returns 64 bit ints as strings
  int: "number",
  float: "number",
  numeric: "number",
  bool: "boolean",
  json: "runtime.Json",
  jsonb: "runtime.Json",
  text: "string",
  char: "string",
  varchar: "string",
  uuid: "string",
  timestamp: "Date",
  timestamptz: "Date"
};

const lines = (...args: Array<string | string[]>): string => {
  return args.flatMap(x => (Array.isArray(x) ? x : [x])).join("\n");
};

const collectQueries = (filePath: string): Array<[string, QueryDef]> => {
  const path = require.resolve(join(process.cwd(), filePath));
  delete require.cache[path];
  const mod: Record<string, QueryDef> = require(path);
  return Object.entries(mod).filter(([, query]) => {
    return query instanceof QueryDef;
  });
};

const pgTypeIdToTsType = (typeMap: types.TypeMap, typeId: number): string => {
  const type = typeMap[typeId];
  const tsTypeName =
    typemap[type.name] ?? typemap[type.name.replace(/\d/g, "")] ?? "unknown";

  if (tsTypeName === "unknown") console.log(type);
  return tsTypeName + (type.isArray ? "[]" : "");
};

const generateInputType = (
  types: types.TypeMap,
  desc: types.QueryDescription,
  query: QueryDef
): string[] => {
  return Array.from(new Set(query.keys)).map((k, i) => {
    return `${k}: ${pgTypeIdToTsType(types, desc.input[i])}`;
  });
};

const generateReturnType = (
  types: types.TypeMap,
  desc: types.QueryDescription
): string[] => {
  return desc.output.map(field => {
    return `${field.name}: ${pgTypeIdToTsType(types, field.dataTypeID)}`;
  });
};

const generateQuery = async (
  { conn, types }: Context,
  name: string,
  query: QueryDef
): Promise<{ code: string; error?: string }> => {
  const id = name.charAt(0).toUpperCase() + name.substring(1);
  const description = await describeQuery(conn, query.sql);

  if (description instanceof DatabaseError) {
    return {
      error: explainQueryError(query.sql, description),
      code: lines(
        "// Query error",
        `export type ${id}Input = never`,
        `export type ${id}Output = never`,
        `export const ${name} = null`
      )
    };
  }

  return {
    code: lines(
      `export interface ${id}Input {`,
      generateInputType(types, description, query).map(s => "  " + s),
      `}`,
      "",
      `export interface ${id}Output {`,
      generateReturnType(types, description).map(s => "  " + s),
      `}`,
      "",
      `export const ${name} = new runtime.Query<${id}Input, ${id}Output>(`,
      `  ${JSON.stringify(query.sql)},`,
      `  ${query.keys.length ? JSON.stringify(query.keys) : "undefined"}`,
      `)`
    )
  };
};

const writeFile = async (ctx: Context, sourceFile: string): Promise<void> => {
  const queryCode = await Promise.all(
    collectQueries(sourceFile).map(async ([name, query]) => {
      const { code, error } = await generateQuery(ctx, name, query);
      if (error) {
        console.error(`${sourceFile} -> ${name} ${red("error")}`);
        console.error(yellow(error));
      } else {
        console.log(`${sourceFile} -> ${name} ${green("ok")}`);
      }
      return code;
    })
  );

  const code = lines(
    "import * as runtime from 'sqling/lib/runtime'",
    "",
    "/* THIS FILE IS AUTOMATICALLY GENERATED BY SQLING. DO NOT EDIT IT DIRECTLY */",
    "",
    ...queryCode
  );

  const destFile = sourceFile.replace(".sql.ts", ".ts");
  assert(destFile !== sourceFile, "attempted to overwrite input file");
  fs.writeFileSync(destFile, code, { encoding: "utf8" });
};

export const generate = async ({
  glob,
  pgConfig,
  afterWrite = () => {}
}: {
  glob: string | string[];
  pgConfig: ClientConfig;
  afterWrite?: (path: string) => void | Promise<void>;
}): Promise<void> => {
  const mutexes: Record<string, Mutex> = {};
  const context = {
    conn: await connect(pgConfig),
    types: await getPgTypes(pgConfig)
  };

  chokidar.watch(glob).on("all", (_event, path, _stats) => {
    if (!path.endsWith(".sql.ts")) {
      console.warn("unexpected input file: " + path);
      console.warn("sqling will only process files ending in .sql.ts");
      console.warn("change your glob pattern to only match those files");
      return;
    }

    if (!mutexes[path]) {
      mutexes[path] = new Mutex();
    }
    mutexes[path].synchronize(async () => {
      try {
        await writeFile(context, path);
        await afterWrite(path);
      } catch (e) {
        console.error(e);
      }
    });
  });
};
