import assert from "assert";
import fs from "fs";
import { join } from "path";
import chokidar from "chokidar";
import { ClientConfig } from "pg";
import { connect, describeQuery, getPgTypes } from "./db";
import { QueryDef } from "./builder";
import * as types from "./types";

interface Context {
  conn: types.Connection;
  types: types.TypeMap;
}

const typemap: Record<string, string> = {
  int8: "string", // node-postgres also returns 64 bit ints as strings
  int: "number",
  float: "number",
  numeric: "number",
  bool: "boolean",
  json: "runtime.Json",
  jsonb: "runtime.Json",
  text: "string",
  char: "string",
  varchar: "string",
  uuid: "string",
  timestamp: "Date",
  timestamptz: "Date"
};

const collectQueries = (filePath: string): Array<[string, QueryDef]> => {
  const path = require.resolve(join(process.cwd(), filePath));
  delete require.cache[path];
  const mod: Record<string, QueryDef> = require(path);
  return Object.entries(mod).filter(([, query]) => {
    return query instanceof QueryDef;
  });
};

const pgTypeIdToTsType = (typeMap: types.TypeMap, typeId: number): string => {
  const type = typeMap[typeId];
  const tsTypeName =
    typemap[type.name] ?? typemap[type.name.replace(/\d/g, "")] ?? "unknown";

  if (tsTypeName === "unknown") console.log(type);
  return tsTypeName + (type.isArray ? "[]" : "");
};

const generateInputType = (
  types: types.TypeMap,
  desc: types.QueryDescription,
  query: QueryDef
): string[] => {
  return Array.from(new Set(query.keys)).map((k, i) => {
    return `${k}: ${pgTypeIdToTsType(types, desc.input[i])}`;
  });
};

const generateReturnType = (
  types: types.TypeMap,
  desc: types.QueryDescription
): string[] => {
  return desc.output.map(field => {
    return `${field.name}: ${pgTypeIdToTsType(types, field.dataTypeID)}`;
  });
};

const generateQuery = async (
  { conn, types }: Context,
  name: string,
  query: QueryDef
) => {
  const id = name.charAt(0).toUpperCase() + name.substring(1);
  const description = await describeQuery(conn, query.sql);

  return `
export interface ${id}Input {
  ${generateInputType(types, description, query).join("\n  ")}
}

export interface ${id}Output {
  ${generateReturnType(types, description).join("\n  ")}
}

export const ${name} = new runtime.Query<${id}Input, ${id}Output>(
  ${JSON.stringify(query.sql)},
  ${query.keys.length ? JSON.stringify(query.keys) : "undefined"}
)`;
};

const writeFile = async (ctx: Context, sourceFile: string): Promise<void> => {
  const queries = collectQueries(sourceFile);

  const queryCode = [];
  for (const [name, query] of queries) {
    queryCode.push(await generateQuery(ctx, name, query));
  }

  const code = [
    "import * as runtime from 'sqling/lib/runtime'",
    "/* THIS FILE IS AUTOMATICALLY GENERATED BY SQLING. DO NOT EDIT IT DIRECTLY */",
    ...queryCode
  ].join("\n\n");

  const destFile = sourceFile.replace(".sql.ts", ".ts");
  assert(destFile !== sourceFile, "attempted to overwrite input file");
  fs.writeFileSync(destFile, code, { encoding: "utf8" });
  console.log("generated", destFile);
};

export const generate = async ({
  glob,
  pgConfig,
  afterWrite = () => {}
}: {
  glob: string | string[];
  pgConfig: ClientConfig;
  afterWrite?: (path: string) => void | Promise<void>;
}): Promise<void> => {
  const context = {
    conn: await connect(pgConfig),
    types: await getPgTypes(pgConfig)
  };

  chokidar.watch(glob).on("all", (_event, path, _stats) => {
    if (!path.endsWith(".sql.ts")) {
      console.warn("unexpected input file: " + path);
      console.warn("sqling will only process files ending in .sql.ts");
      console.warn("change your glob pattern to only match those files");
      return;
    }

    writeFile(context, path).catch(console.error);
    const after = afterWrite(path);
    if (after && "catch" in after) {
      after.catch(console.error);
    }
  });
};
